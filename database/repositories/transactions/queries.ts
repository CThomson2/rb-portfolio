// database/repositories/products/queries.ts
import { prisma } from "@/database/client";
import type {
  Transaction,
  TransactionRow,
} from "@/types/database/transactions";
import {
  TransactionVariant,
  type TransactionVariantType,
} from "@/types/constant/transactions";

interface CreateTransactionInput {
  tx_type: TransactionVariantType; // "import" | "processing" | "reprocessing" | "disposal" | "loss"
  tx_date?: Date; // optional, if defaulting to CURRENT_DATE
  material?: string | null;
  delivery_id?: number | null;
  drum_id?: number | null;
  repro_id?: number | null;
  process_id?: number | null;
  tx_notes?: string | null;
  batch_code?: string | null;
}

export const queries = {
  /**
   * Gets the 100 most recent inventory transactions with material names.
   * Joins with imports, new drums, and repro drums tables to get the material name
   * based on which ID is present in the transaction.
   * @returns Promise resolving to array of transactions with material names
  
   */
  getTransactions: async (
    page = 1,
    limit = 50
  ): Promise<{ rows: TransactionRow[]; total: number }> => {
    const offset = (page - 1) * limit;

    // Get the total number of transactions
    const totalResult = await prisma.$queryRaw<{ total: number }[]>`
    SELECT COUNT(*) as total FROM inventory.transactions
  `;
    const total = Number(totalResult[0].total);

    // Then get the paginated data, with LEFT JOINs to get the material name
    const result = await prisma.$queryRaw`
    SELECT
      t.*,
      CASE
        WHEN t.delivery_id IS NOT NULL THEN o.material
        WHEN t.drum_id IS NOT NULL THEN nd.material
        WHEN t.repro_id IS NOT NULL THEN rd.material
      END as material_name
    FROM inventory.transactions t
    LEFT JOIN inventory.deliveries d ON t.delivery_id = d.delivery_id
    LEFT JOIN inventory.orders o ON d.order_id = o.order_id
    LEFT JOIN inventory.new_drums nd ON t.drum_id = nd.drum_id
    LEFT JOIN inventory.repro_drums rd ON t.repro_id = rd.repro_drum_id
    ORDER BY t.tx_id DESC
    LIMIT ${limit}
    OFFSET ${offset}
  `;

    return {
      rows: result as TransactionRow[],
      total,
    };

    // // Use a CTE (Common Table Expression) for better performance
    // const result = await prisma.$queryRaw`
    //   WITH MaterialInfo AS (
    //     SELECT
    //       d.delivery_id,
    //       o.material as delivery_material,
    //       nd.drum_id,
    //       nd.material as drum_material,
    //       rd.repro_drum_id,
    //       rd.material as repro_material
    //     FROM inventory.deliveries d
    //     LEFT JOIN inventory.orders o ON d.order_id = o.order_id
    //     LEFT JOIN inventory.new_drums nd ON nd.drum_id = nd.drum_id
    //     LEFT JOIN inventory.repro_drums rd ON rd.repro_drum_id = rd.repro_drum_id
    //   )
    //   SELECT
    //     t.*,
    //     COALESCE(
    //       mi.delivery_material,
    //       mi.drum_material,
    //       mi.repro_material
    //     ) as material_name,
    //     COUNT(*) OVER() as total_count
    //   FROM inventory.transactions t
    //   LEFT JOIN MaterialInfo mi ON
    //     t.delivery_id = mi.delivery_id OR
    //     t.drum_id = mi.drum_id OR
    //     t.repro_id = mi.repro_drum_id
    //   ORDER BY t.tx_date DESC
    //   LIMIT ${limit}
    //   OFFSET ${offset}
    // `;

    // return { rows, total };
  },

  getTransactionById: async (id: string) => {
    return await prisma.transactions.findUnique({
      where: { tx_id: parseInt(id) },
    });
  },

  createTransaction: async (transactionData: CreateTransactionInput) => {
    const {
      tx_type,
      tx_date = new Date(), // defaults to CURRENT_DATE
      // direction generated by DB
      material = null,
      delivery_id = null,
      drum_id = null,
      repro_id = null,
      process_id = null,
      tx_notes = null,
      batch_code = null,
    } = transactionData;

    // Basic validation logic to enforce which fields must be present vs. null
    switch (tx_type) {
      case "import":
        // import => delivery_id required, drum_id & repro_id must be null
        if (!delivery_id) {
          throw new Error("delivery_id is required for 'import' transactions.");
        }
        if (drum_id || repro_id) {
          throw new Error(
            "drum_id and repro_id must be null for 'import' transactions."
          );
        }
        // direction can be left to DB if it’s stored or derived,
        // but you can also do direction = 'IN' here if needed
        break;

      case "processing":
        // processing => drum_id & process_id required, delivery_id & repro_id must be null
        if (!drum_id) {
          throw new Error("drum_id is required for 'processing' transactions.");
        }
        if (!process_id) {
          throw new Error(
            "process_id is required for 'processing' transactions."
          );
        }
        if (delivery_id || repro_id) {
          throw new Error(
            "delivery_id and repro_id must be null for 'processing' transactions."
          );
        }
        break;

      case "reprocessing":
        // reprocessing => repro_id & process_id required, delivery_id & drum_id must be null
        if (!repro_id) {
          throw new Error(
            "repro_id is required for 'reprocessing' transactions."
          );
        }
        if (!process_id) {
          throw new Error(
            "process_id is required for 'reprocessing' transactions."
          );
        }
        if (delivery_id || drum_id) {
          throw new Error(
            "delivery_id and drum_id must be null for 'reprocessing' transactions."
          );
        }
        break;

      case "disposal":
      case "loss":
        // disposal/loss => often requires a drum_id to know which drum we’re disposing
        // (if your DB logic requires that, specify it here)
        if (!drum_id) {
          throw new Error(`drum_id is required for '${tx_type}' transactions.`);
        }
        // For disposal/loss, confirm other fields are null if that’s your rule
        if (delivery_id || repro_id || process_id) {
          throw new Error(
            "delivery_id, repro_id, and process_id must be null for disposal/loss transactions."
          );
        }
        break;

      default:
        throw new Error(
          `Invalid tx_type "${tx_type}". Valid types: import, processing, reprocessing, disposal, loss.`
        );
    }

    // If validation passes, proceed with creating the record
    const newTransaction = await prisma.transactions.create({
      data: {
        tx_type,
        tx_date,
        material,
        delivery_id,
        drum_id,
        repro_id,
        process_id,
        tx_notes,
        batch_code,
      },
    });

    // Return the newly created transaction record with all fields (can be destructured)
    return newTransaction;
  },
};
